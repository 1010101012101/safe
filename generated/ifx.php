<?php

namespace Safe;

/**
 * Set the default blob mode for all select queries.
 * 
 * @param int $mode Mode "0" means save Byte-Blobs in memory, and mode "1" means save
 * Byte-Blobs in a file.
 * @throws Exceptions\IfxException
 * 
 */
function ifx_blobinfile_mode(int $mode): void
{
    error_clear_last();
    $result = \ifx_blobinfile_mode($mode);
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
}


/**
 * Sets the default byte mode for all select-queries.
 * 
 * @param int $mode Mode "0" will return a blob id, and mode "1" will return a varchar
 * with text content.
 * @throws Exceptions\IfxException
 * 
 */
function ifx_byteasvarchar(int $mode): void
{
    error_clear_last();
    $result = \ifx_byteasvarchar($mode);
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
}


/**
 * ifx_close closes the link to an Informix
 * database that's associated with the specified link identifier.
 * 
 * Note that this isn't usually necessary, as non-persistent open
 * links are automatically closed at the end of the script's
 * execution.
 * 
 * ifx_close will not close persistent links
 * generated by ifx_pconnect.
 * 
 * @param resource $link_identifier The link identifier. If not specified, the last opened link is
 * assumed.
 * @throws Exceptions\IfxException
 * 
 */
function ifx_close($link_identifier = null): void
{
    error_clear_last();
    if ($link_identifier !== null) {
        $result = \ifx_close($link_identifier);
    }else {
        $result = \ifx_close();
    }
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
}


/**
 * ifx_connect establishes a connection to an Informix
 * server.
 * 
 * In case a second call is made to ifx_connect with the
 * same arguments, no new link will be established, but instead, the link
 * identifier of the already opened link will be returned.
 * 
 * The link to the server will be closed as soon as the execution of the
 * script ends, unless it's closed earlier by explicitly calling
 * ifx_close.
 * 
 * @param string $database The database name, as a string.
 * @param string $userid The username, as a string.
 * @param string $password The password, as a string.
 * @return resource Returns a connection identifier on success, .
 * @throws Exceptions\IfxException
 * 
 */
function ifx_connect(string $database = null, string $userid = null, string $password = null)
{
    error_clear_last();
    if ($password !== null) {
        $result = \ifx_connect($database, $userid, $password);
    } elseif ($userid !== null) {
        $result = \ifx_connect($database, $userid);
    } elseif ($database !== null) {
        $result = \ifx_connect($database);
    }else {
        $result = \ifx_connect();
    }
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
    return $result;
}


/**
 * Duplicates the given blob object.
 * 
 * @param int $bid A BLOB identifier.
 * @return int Returns the new blob object-id, s.
 * @throws Exceptions\IfxException
 * 
 */
function ifx_copy_blob(int $bid): int
{
    error_clear_last();
    $result = \ifx_copy_blob($bid);
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
    return $result;
}


/**
 * Creates a blob object.
 * 
 * @param int $type 1 = TEXT, 0 = BYTE
 * @param int $mode 0 = blob-object holds the content in memory,
 * 1 = blob-object holds the content in file.
 * @param string $param if mode = 0: pointer to the content,
 * if mode = 1: pointer to the filestring.
 * @return int Returns the new BLOB object-id, s.
 * @throws Exceptions\IfxException
 * 
 */
function ifx_create_blob(int $type, int $mode, string $param): int
{
    error_clear_last();
    $result = \ifx_create_blob($type, $mode, $param);
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
    return $result;
}


/**
 * Creates an char object.
 * 
 * @param string $param The char content.
 * @return int Returns the new char object id, s.
 * @throws Exceptions\IfxException
 * 
 */
function ifx_create_char(string $param): int
{
    error_clear_last();
    $result = \ifx_create_char($param);
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
    return $result;
}


/**
 * Executes a previously prepared query or opens a cursor for it.
 * 
 * Does NOT free result_id on error.
 * 
 * Also sets the real number of
 * ifx_affected_rows for non-select statements
 * for retrieval by ifx_affected_rows.
 * 
 * @param resource $result_id result_id is a valid resultid returned by
 * ifx_query or
 * ifx_prepare (select type queries only!).
 * @throws Exceptions\IfxException
 * 
 */
function ifx_do($result_id): void
{
    error_clear_last();
    $result = \ifx_do($result_id);
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
}


/**
 * Returns the Informix SQL fieldproperties of every field in the
 * query as an associative array.  Properties are encoded as:
 * "SQLTYPE;length;precision;scale;ISNULLABLE" where SQLTYPE = the
 * Informix type like "SQLVCHAR" etc. and ISNULLABLE = "Y" or "N".
 * 
 * @param resource $result_id result_id is a valid resultid returned by
 * ifx_query or
 * ifx_prepare (select type queries only!).
 * @return array Returns an associative array with fieldnames as key and the SQL 
 * fieldproperties as data for a query with result_id.
 * Returns FALSE on errors.
 * @throws Exceptions\IfxException
 * 
 */
function ifx_fieldproperties($result_id): array
{
    error_clear_last();
    $result = \ifx_fieldproperties($result_id);
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
    return $result;
}


/**
 * Returns an associative array with fieldnames as key and the SQL
 * fieldtypes as data for the query associated with
 * result_id.
 * 
 * @param resource $result_id result_id is a valid resultid returned by
 * ifx_query or
 * ifx_prepare (select type queries only!).
 * @return array Returns an associative array with fieldnames as key and the SQL
 * fieldtypes as data for query with
 * result_id.  Returns FALSE on error.
 * @throws Exceptions\IfxException
 * 
 */
function ifx_fieldtypes($result_id): array
{
    error_clear_last();
    $result = \ifx_fieldtypes($result_id);
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
    return $result;
}


/**
 * Deletes the blobobject for the given blob object-id.
 * 
 * @param int $bid The BLOB object id.
 * @throws Exceptions\IfxException
 * 
 */
function ifx_free_blob(int $bid): void
{
    error_clear_last();
    $result = \ifx_free_blob($bid);
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
}


/**
 * Deletes the charobject for the given char object-id.
 * 
 * @param int $bid The char object id.
 * @throws Exceptions\IfxException
 * 
 */
function ifx_free_char(int $bid): void
{
    error_clear_last();
    $result = \ifx_free_char($bid);
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
}


/**
 * Releases resources for the query associated with
 * result_id.
 * 
 * @param resource $result_id result_id is a valid resultid returned by
 * ifx_query or
 * ifx_prepare (select type queries only!).
 * @throws Exceptions\IfxException
 * 
 */
function ifx_free_result($result_id): void
{
    error_clear_last();
    $result = \ifx_free_result($result_id);
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
}


/**
 * Returns the content of the blob object.
 * 
 * @param int $bid The BLOB object id.
 * @return string The contents of the BLOB as a string, s.
 * @throws Exceptions\IfxException
 * 
 */
function ifx_get_blob(int $bid): string
{
    error_clear_last();
    $result = \ifx_get_blob($bid);
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
    return $result;
}


/**
 * Returns the content of the char object.
 * 
 * @param int $bid The char object-id.
 * @return string Returns the contents as a string, s.
 * @throws Exceptions\IfxException
 * 
 */
function ifx_get_char(int $bid): string
{
    error_clear_last();
    $result = \ifx_get_char($bid);
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
    return $result;
}


/**
 * Formats and prints all rows of the result_id query
 * into a HTML table.
 * 
 * @param resource $result_id result_id is a valid resultid returned by
 * ifx_query or
 * ifx_prepare (select type queries only!).
 * @param string $html_table_options This optional argument is a string of &lt;table&gt; tag options.
 * @return int Returns the number of fetched rows, s.
 * @throws Exceptions\IfxException
 * 
 */
function ifx_htmltbl_result($result_id, string $html_table_options = null): int
{
    error_clear_last();
    if ($html_table_options !== null) {
        $result = \ifx_htmltbl_result($result_id, $html_table_options);
    }else {
        $result = \ifx_htmltbl_result($result_id);
    }
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
    return $result;
}


/**
 * Sets the default return value of a NULL-value on a fetch row.
 * 
 * @param int $mode Mode "0" returns "", and mode "1" returns "NULL".
 * @throws Exceptions\IfxException
 * 
 */
function ifx_nullformat(int $mode): void
{
    error_clear_last();
    $result = \ifx_nullformat($mode);
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
}


/**
 * After preparing or executing a query, this call gives you the
 * number of columns in the query.
 * 
 * @param resource $result_id result_id is a valid resultid returned by
 * ifx_query or
 * ifx_prepare (select type queries only!).
 * @return int Returns the number of columns in query for
 * result_id, s.
 * @throws Exceptions\IfxException
 * 
 */
function ifx_num_fields($result_id): int
{
    error_clear_last();
    $result = \ifx_num_fields($result_id);
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
    return $result;
}


/**
 * Gives the number of rows fetched so far for a query with
 * result_id after a
 * ifx_query or ifx_do
 * query.
 * 
 * @param resource $result_id result_id is a valid resultid returned by
 * ifx_query or
 * ifx_prepare (select type queries only!).
 * @return int Returns the number of fetched rows s.
 * @throws Exceptions\IfxException
 * 
 */
function ifx_num_rows($result_id): int
{
    error_clear_last();
    $result = \ifx_num_rows($result_id);
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
    return $result;
}


/**
 * ifx_pconnect acts very much like
 * ifx_connect with two major differences.
 * 
 * First, when connecting, the function would first try to find a
 * (persistent) link that's already open with the same host,
 * username and password.  If one is found, an identifier for it
 * will be returned instead of opening a new connection.
 * 
 * Second, the connection to the SQL server will not be closed when
 * the execution of the script ends.  Instead, the link will remain
 * open for future use (ifx_close will not
 * close links established by ifx_pconnect).
 * 
 * This type of links is therefore called 'persistent'.
 * 
 * @param string $database The database name, as a string.
 * @param string $userid The username, as a string.
 * @param string $password The password, as a string.
 * @return resource Returns: valid Informix persistent link identifier on success, s.
 * @throws Exceptions\IfxException
 * 
 */
function ifx_pconnect(string $database = null, string $userid = null, string $password = null)
{
    error_clear_last();
    if ($password !== null) {
        $result = \ifx_pconnect($database, $userid, $password);
    } elseif ($userid !== null) {
        $result = \ifx_pconnect($database, $userid);
    } elseif ($database !== null) {
        $result = \ifx_pconnect($database);
    }else {
        $result = \ifx_pconnect();
    }
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
    return $result;
}


/**
 * Prepares a query for later use with
 * ifx_do.
 * 
 * For "select-type" queries a cursor is declared and opened.
 * Non-select queries are "execute immediate".
 * 
 * For either query type the number of (estimated or real) affected rows is
 * saved for retrieval by ifx_affected_rows.
 * 
 * If the contents of the TEXT (or BYTE) column allow it, you can also use
 * ifx_textasvarchar(1) and 
 * ifx_byteasvarchar(1).  This allows you to treat TEXT
 * (or BYTE) columns just as if they were ordinary (but long) VARCHAR columns
 * for select queries, and you don't need to bother with blob id's.
 * 
 * With ifx_textasvarchar(0) or 
 * ifx_byteasvarchar(0) (the default situation), select
 * queries will return BLOB columns as blob id's (integer value).  You can
 * get the value of the blob as a string or file with the blob functions (see
 * below).
 * 
 * @param string $query The query string.
 * @param resource $link_identifier The link identifier.
 * @param int $cursor_def This optional parameter allows you to make this a 
 * scroll and/or hold cursor.
 * It's a bitmask and can be either IFX_SCROLL,
 * IFX_HOLD, or both or'ed together.
 * @param mixed $blobidarray If you have BLOB (BYTE or TEXT) columns in the query, you can add
 * a blobidarray parameter containing the
 * corresponding "blob ids", and you should replace those columns
 * with a "?" in the query text.
 * @return resource Returns a valid result identifier for use by ifx_do,
 * s.
 * @throws Exceptions\IfxException
 * 
 */
function ifx_prepare(string $query, $link_identifier, int $cursor_def = null, $blobidarray = null)
{
    error_clear_last();
    if ($blobidarray !== null) {
        $result = \ifx_prepare($query, $link_identifier, $cursor_def, $blobidarray);
    } elseif ($cursor_def !== null) {
        $result = \ifx_prepare($query, $link_identifier, $cursor_def);
    }else {
        $result = \ifx_prepare($query, $link_identifier);
    }
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
    return $result;
}


/**
 * Sends a query to the currently active database on
 * the server that's associated with the specified link identifier.
 * 
 * For "select-type" queries a cursor is declared and opened.
 * Non-select queries are "execute immediate".
 * 
 * For either query type the number of (estimated or real) affected rows is
 * saved for retrieval by ifx_affected_rows.
 * 
 * If the contents of the TEXT (or BYTE) column allow it, you can also use
 * ifx_textasvarchar(1) and 
 * ifx_byteasvarchar(1).  This allows you to treat TEXT
 * (or BYTE) columns just as if they were ordinary (but long) VARCHAR columns
 * for select queries, and you don't need to bother with blob id's.
 * 
 * With ifx_textasvarchar(0) or 
 * ifx_byteasvarchar(0) (the default situation), select
 * queries will return BLOB columns as blob id's (integer value).  You can
 * get the value of the blob as a string or file with the blob functions (see
 * below).
 * 
 * @param string $query The query string.
 * @param resource $link_identifier The link identifier.
 * @param int $cursor_type This optional parameter allows you to make this a 
 * scroll and/or hold cursor.
 * It's a bitmask and can be either IFX_SCROLL,
 * IFX_HOLD, or both or'ed together. I you omit this
 * parameter the cursor is a normal sequential cursor.
 * @param mixed $blobidarray If you have BLOB (BYTE or TEXT) columns in the query, you can add
 * a blobidarray parameter containing the
 * corresponding "blob ids", and you should replace those columns
 * with a "?" in the query text.
 * @return resource Returns valid Informix result identifier on success, s.
 * @throws Exceptions\IfxException
 * 
 */
function ifx_query(string $query, $link_identifier, int $cursor_type = null, $blobidarray = null)
{
    error_clear_last();
    if ($blobidarray !== null) {
        $result = \ifx_query($query, $link_identifier, $cursor_type, $blobidarray);
    } elseif ($cursor_type !== null) {
        $result = \ifx_query($query, $link_identifier, $cursor_type);
    }else {
        $result = \ifx_query($query, $link_identifier);
    }
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
    return $result;
}


/**
 * Sets the default text mode for all select-queries.
 * 
 * @param int $mode Mode "0" will return a blob id, and mode "1" will return a varchar
 * with text content.
 * @throws Exceptions\IfxException
 * 
 */
function ifx_textasvarchar(int $mode): void
{
    error_clear_last();
    $result = \ifx_textasvarchar($mode);
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
}


/**
 * Updates the content of the blob object for the given blob object
 * bid.
 * 
 * @param int $bid A BLOB object identifier.
 * @param string $content The new data, as a string.
 * @throws Exceptions\IfxException
 * 
 */
function ifx_update_blob(int $bid, string $content): void
{
    error_clear_last();
    $result = \ifx_update_blob($bid, $content);
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
}


/**
 * Updates the content of the char object for the given char object
 * bid.
 * 
 * @param int $bid A char object identifier.
 * @param string $content The new data, as a string.
 * @throws Exceptions\IfxException
 * 
 */
function ifx_update_char(int $bid, string $content): void
{
    error_clear_last();
    $result = \ifx_update_char($bid, $content);
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
}


/**
 * Deletes the slob object on the given slob object-id
 * bid.
 * 
 * @param int $bid An existing slob id.
 * @throws Exceptions\IfxException
 * 
 */
function ifxus_close_slob(int $bid): void
{
    error_clear_last();
    $result = \ifxus_close_slob($bid);
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
}


/**
 * Creates an slob object and opens it.
 * 
 * @param int $mode A combination of IFX_LO_RDONLY, 
 * IFX_LO_WRONLY, IFX_LO_APPEND
 * IFX_LO_RDWR, IFX_LO_BUFFER,
 * IFX_LO_NOBUFFER.
 * @return int Return the new slob object-id, s.
 * @throws Exceptions\IfxException
 * 
 */
function ifxus_create_slob(int $mode): int
{
    error_clear_last();
    $result = \ifxus_create_slob($mode);
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
    return $result;
}


/**
 * Deletes the slob object.
 * 
 * @param int $bid An existing slob id.
 * @throws Exceptions\IfxException
 * 
 */
function ifxus_free_slob(int $bid): void
{
    error_clear_last();
    $result = \ifxus_free_slob($bid);
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
}


/**
 * Opens an slob object. bid should be an
 * existing slob id.
 * 
 * @param int $bid An existing slob id.
 * @param int $mode A combination of IFX_LO_RDONLY, 
 * IFX_LO_WRONLY, IFX_LO_APPEND
 * IFX_LO_RDWR, IFX_LO_BUFFER,
 * IFX_LO_NOBUFFER.
 * @return int Returns the new slob object-id, s.
 * @throws Exceptions\IfxException
 * 
 */
function ifxus_open_slob(int $bid, int $mode): int
{
    error_clear_last();
    $result = \ifxus_open_slob($bid, $mode);
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
    return $result;
}


/**
 * Reads nbytes of the slob object.
 * 
 * @param int $bid An existing slob id.
 * @param int $nbytes The number of bytes to read.
 * @return string Returns the slob contents as a string, s.
 * @throws Exceptions\IfxException
 * 
 */
function ifxus_read_slob(int $bid, int $nbytes): string
{
    error_clear_last();
    $result = \ifxus_read_slob($bid, $nbytes);
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
    return $result;
}


/**
 * Sets the current file or seek position of an open slob object.
 * 
 * @param int $bid An existing slob id.
 * @param int $mode 0 = LO_SEEK_SET, 1 = LO_SEEK_CUR, 2 = LO_SEEK_END.
 * @param int $offset A byte offset.
 * @return int Returns the seek position as an integer, s.
 * @throws Exceptions\IfxException
 * 
 */
function ifxus_seek_slob(int $bid, int $mode, int $offset): int
{
    error_clear_last();
    $result = \ifxus_seek_slob($bid, $mode, $offset);
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
    return $result;
}


/**
 * Returns the current file or seek position of an open slob object
 * 
 * @param int $bid An existing slob id.
 * @return int Returns the seek position as an integer, s.
 * @throws Exceptions\IfxException
 * 
 */
function ifxus_tell_slob(int $bid): int
{
    error_clear_last();
    $result = \ifxus_tell_slob($bid);
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
    return $result;
}


/**
 * Writes a string into the slob object.
 * 
 * @param int $bid An existing slob id.
 * @param string $content The content to write, as a string.
 * @return int Returns the bytes written as an integer, s.
 * @throws Exceptions\IfxException
 * 
 */
function ifxus_write_slob(int $bid, string $content): int
{
    error_clear_last();
    $result = \ifxus_write_slob($bid, $content);
    if ($result === FALSE) {
        throw Exceptions\IfxException::createFromPhpError();
    }
    return $result;
}


